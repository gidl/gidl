{"name":"gidl","tagline":"Generalized Interface Definition Language (GIDL)","body":"## Introduction\r\nGIDL **translates between the Interface Definition Languages (IDLs)** of the following messaging frameworks:\r\n- Simple Binary Encoding (SBE)\r\n- Apache Thrift\r\n- Google FlatBuffers\r\n- Google Protocol Buffers (ProtoBuf)\r\n- Cap'n Proto (capnp)\r\n\r\nGIDL uses XML because:\r\n- XML is easy to extend, unknown elements are ignored.\r\n- XML is widely understood.\r\n- XML is supported in most programming languages, so translators can be written in different languages.\r\n- XML eases modeling tool integration.\r\n- For the purpose of translating between IDLs, the weak performance of XML is a non-issue.\r\n\r\nGIDL serves several purposes:\r\n- simplifies migration between the four messaging frameworks\r\n- enables modeling tool integration\r\n- allows easy performance comparisons between the messaging frameworks\r\n\r\n## Translating messaging concepts\r\n\r\n### Basic types\r\nGIDL translates basic types as follows:\r\n\r\nGIDL    |SBE     |Thrift |ProtoBuf                |FlatBuffers |Capnp   |Comment\r\n--------|--------|-------|------------------------|------------|--------|----\r\nbool    |(bit)set|bool   |bool                    |bool        |Bool    |like Java boolean\r\nchar8   |char    |-      |-                       |-           |-       |Signed 8-bit char\r\nsint8   |int8    |byte   |-                       |byte        |Int8    |Signed\r\nsint16  |int16   |i16    |-                       |short       |Int16   |Signed\r\nsint32  |int32   |i32    |sint32, sfixed32, int32 |int         |Int32   |Signed\r\nsint64  |int64   |i64    |sint64, sfixed64, int64 |long        |Int64   |Signed\r\nuint8   |uint8   |-      |-                       |ubyte       |UInt8   |Unsigned\r\nuint16  |uint16  |-      |-                       |ushort      |UInt16  |Unsigned\r\nuint32  |uint32  |-      |uint32, fixed32         |uint        |UInt32  |Unsigned\r\nuint64  |uint64  |-      |uint64, fixed64         |ulong       |UInt64  |Unsigned\r\nfloat32 |float   |-      |float                   |float       |Float32 |like Java float\r\nfloat64 |double  |double |double                  |double      |Float64 |like Java double\r\n\r\n\r\n### String/blob types\r\nGIDL translates string/blob types as follows:\r\n\r\nGIDL    |SBE     |Thrift |ProtoBuf |FlatBuffers |Capnp   |Comment\r\n--------|--------|-------|---------|------------|--------|----\r\ndata    |data    |binary |bytes    |-           |Data    |Binary blob, sequence of bytes\r\nstring  |-       |string |string   |string      |Text    |Blob with character encoding (e.g. UTF-8)\r\n\r\n\r\n### Complex types\r\nGIDL translates the complex type concepts as follows:\r\n\r\nGIDL   |SBE       |Thrift    |ProtoBuf |FlatBuffers |Capnp   |Comment\r\n-------|----------|----------|---------|------------|--------|------------------------\r\nstruct |composite |-         |-        |struct      |group   |set of fields that are encapsulated\r\nenum   |enum      |enum      |enum     |enum        |enum    |wow, the only concept present in all IDLs\r\nmap    |-         |map       |map      |-           |-       |like Java Map\r\nlist   |group     |list      |repeated |vector      |List(T) |like Java List\r\nunion  |-         |union     |oneof    |union       |union   |like C union (alternative space)\r\ntypedef|type      |typedef   |-        |-           |using   |Renaming primitive types\r\nvoid   |-         |void      |void     |-           |Void    |like Java void, only needed for services/interfaces\r\nconst  |-         |const     |-        |-           |const   |constant value\r\n\r\nThe following type concepts were introduced with programming language support or tool support in mind, not focusing on the messaging aspect.\r\nTherefore, they are simplified using the messaging focus only:\r\n- Apache Thrift: \"set\" is simplified using \"list\".\r\n- Apache Thrift: \"exception\" is simplified using \"struct\" combined with \"string\".\r\n- Google FlatBuffers: \"root_type\" is ignored.\r\n- SBE: \"field\" serves to identify fixed size fields of a message, this is done with a \"length\" attribute in GIDL.\r\n\r\n### Messages\r\nGIDL translates the message concepts as follows:\r\n\r\nGIDL      |SBE               |Thrift    |ProtoBuf    |FlatBuffers     |Capnp         |Comment\r\n----------|------------------|----------|------------|----------------|--------------|-----------------\r\nmessage   |message           |struct    |message     |table           |struct        |encapsulates one transmitted message\r\nreference |-                 |reference |reference   |reference       |reference     |references to another message, struct or table\r\n\r\n\r\n## Translating remote service concepts\r\nMessages are the basic building blocks of remote services. However, looking at the detail: building remote services needs more than just messages only. \r\n\r\nWe need to be able to construct three main types of remote services:\r\n  1. unidirectional services\r\n  2. bidirectional asynchronous services\r\n  3. bidirectional synchronous services\r\n\r\nThere are two different approaches how to construct remote services:\r\n  1. unique file IDs, in combination with struct/message/table names\r\n  2. service definitions\r\n\r\nBoth approaches can be applied - but building bidirectional remote services is more difficult without service definitions:\r\n  * Bidirectional service methods consist of both request messages and response messages. To clarify which two messages form the service together, one might add the suffixes \"Request\" and/or \"Response\" to both messages forming one service.\r\n  * Services with many different methods (e.g. an API) are difficult to define, especially when the request message type is the same for some methods.\r\n  * One way to fix this is to split these service methods into different files. Thus, the unique file IDs are used to show which service method is meant. This way, the request message names can be the same, but their definitions are in effect the same. this leads to code redundancy and violates the DRY principle.\r\n  * Another way to fix this is to duplicate the request messages in the same file, giving them different message names. This again leads to code redundancy and violates the DRY principle.\r\n\r\nGIDL translates the different service concepts as follows:\r\n\r\nGIDL      |SBE               |Thrift    |ProtoBuf    |FlatBuffers     |Capnp         |Comment\r\n----------|------------------|----------|------------|----------------|--------------|-----------------\r\nservice   |-                 |service   |service     |-               |interface     |collection of service methods\r\nschema    |message schema    |-         |-           |-               |-             |Root XML element\r\nfileId    |message schema id |-         |-           |file_identifier |@ (unique id) |unique file ID\r\n\r\n\r\nThe missing \"service\" concept in  SBE and FlatBuffers is inconvenient currently, but it is always possible to add a \"service\" concept later on.\r\nThis will improve readability, maintainability, clarity and usability. It is clear that this is not a performance argument, but a software engineering argument solely.\r\n\r\n## Please help and contribute\r\nGIDL is an exciting work in progress.\r\n\r\nPlease feel welcome to contribute to GIDL!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}